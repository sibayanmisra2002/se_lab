1. Class diagram: A class diagram is a visual representation of the classes, interfaces, and their relationships in a software system. It is typically used in object-oriented programming to describe the structure of a system, showing the classes, attributes, and methods that make up the system, as well as the relationships between them. A class diagram can be used to analyze, design, and document a system.

2. Object: In software engineering, an object is an instance of a class that contains data and methods to operate on that data. Objects are the basic building blocks of object-oriented programming, which is a popular programming paradigm. An object has a state, which is defined by its attributes, and behavior, which is defined by its methods.

3. Sequence: A sequence diagram is a type of interaction diagram that shows the interactions between objects in a system over time. It is used to model behavior and describe how objects interact with each other to perform a particular task or function. A sequence diagram shows the messages that are passed between objects and the order in which they occur, making it useful for analyzing and designing software systems.

4. SRS: A Software Requirements Specification (SRS) is a document that outlines the functional and non-functional requirements of a software system. It is typically created during the requirements gathering phase of software development and is used to communicate the requirements to stakeholders such as developers, testers, and project managers. An SRS describes what the system must do and how it should behave in various situations.

5. Decision tree: A decision tree is a diagram that represents a sequence of decisions and their possible consequences. It is often used in decision-making processes to help make choices based on multiple criteria. A decision tree is made up of nodes, which represent the decision points, and branches, which represent the possible outcomes of those decisions.

6. Decision table: A decision table is a matrix that maps the possible combinations of inputs and outputs for a set of rules or decisions. It is used to describe complex logic in a structured and organized way. A decision table is made up of columns, which represent the inputs or conditions, and rows, which represent the outputs or actions.

7. Activity diagram: An activity diagram is a graphical representation of the workflow or activity within a system. It is often used to model business processes and to describe how a system functions. An activity diagram shows the steps or activities that make up a process, the decisions that need to be made, and the order in which the activities occur.

8. Collaboration: A collaboration diagram, also known as a communication diagram, is a diagram that shows the interactions between objects or components in a system. It is often used to model the communication patterns between objects in a system. A collaboration diagram shows the objects or components involved in the interaction, the messages that are passed between them, and the order in which they occur.

9. State chart: A state chart, also known as a state machine diagram, is a diagram that shows the states and transitions of an object or system. It is often used to model behavior and to describe how a system reacts to different events or stimuli. A state chart shows the states of an object, the events that trigger transitions between states, and the actions or behaviors that occur when a transition takes place.

10. Data flow: Data flow is the movement of data through a system or process. It is often shown in a diagram to illustrate the flow of information. A data flow diagram (DFD) is a graphical representation of the flow of data through a system, showing the processes, data stores, and data flows involved in the system.

11. Use case: A use case is a description of a user's interaction with a system to accomplish a specific goal. It describes the steps that a user takes to complete a task and the response of the system to those actions. Use cases are often used in software development to define the requirements of a system and to communicate those requirements to stakeholders.

12. COCOMO model: The COCOMO model is a software cost estimation model that was developed by Barry Boehm in the 1980s. It is used to estimate the effort and cost required to develop a software system based on the size of the system and the complexity of the development process. The COCOMO model is based on three different levels of estimation: Basic, Intermediate, and Advanced.

13. McCabe's Cyclomatic Complexity: McCabe's Cyclomatic Complexity is a measure of the complexity of a software system. It is calculated by counting the number of independent paths through a program's source code. The higher the cyclomatic complexity, the more complex the software system is, and the more difficult it is to understand, test, and maintain.

14. Blackbox testing and white box testing: The main difference between black box testing and white box testing is the level of knowledge the tester has about the system being tested. Black box testing is a method of testing where the tester does not have any knowledge of the internal workings of the system being tested. The tester only has access to the inputs and outputs of the system and tests it from an end-user perspective. White box testing, on the other hand, is a method of testing where the tester has full knowledge of the internal workings of the system being tested. The tester has access to the source code, architecture, and design of the system and tests it from a developer perspective. White box testing is often used to test individual components or modules of a software system, while black box testing is used to test the system as a whole.